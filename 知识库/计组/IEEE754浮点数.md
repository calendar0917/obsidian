## 1. 核心解构
* **公式**：$V = (-1)^S \times (1.M) \times 2^{E-Bias}$。
* 单精度 32 bit，双精度 64 bit
* **三大组件**：
    1.  **S (Sign)**：符号位，1为负，0为正。
    2.  **E (Exponent)**：阶码，采用**移码 (Bias)** 表示。
        * 单精度 Bias = 127，双精度 Bias = 1023。
        * *为什么用移码？* 为了方便浮点数比大小（直接比较二进制串即可，无需处理符号位）。
	        * 移码 = 补码的符号位取反
    3.  **M (Mantissa)**：尾数，隐含了最高位的 "1"（规格化数），从而多获得1位精度。

>[!example] 为什么要用 127 来做偏置值？
>由于阶码 0、255 保留，故真值指数范围为： -126 ~ 127
>选127，最大指数能更大，所损失的只是最小的正数

>[!补充] 补充
>定点小数：整数位表示符号，后面
>- 原码：不变
>- 反码：取反
>- 补码：反码末尾加一



- 存储阶码 = 真实阶码 + Bias
	- 对于 k 位阶码，Bias 的取值为 $(2^{k-1} - 1)$，单精度 8 位，双精度 11 位
	- 通过引入阶码，所有有效阶码的存储值都**统一**为非负整数

- 规格化
	- - 二进制 101.1（对应十进制 5.5）→ 小数点左移 2 位 -> 1.011，指数 + 2 → 规格化形式：1.011×2²
	- 默认整数位为 1
- 非规格化数：
	- 阶码可以全零或全1，但是尾数不能为0，为了填补 0 到 $2^{-126}$ 之间的空隙。尾数不再隐含 `1.`

## 2. 特殊值与漏洞
机器不仅能表示数，还能表示“状态”：
* **NaN (Not a Number)**：$E=全1, M \neq 0$。用于调试或攻击（如 Poisoning AI Model）。
* **Infinity ($\pm \infty$)**：$E=全1, M=0$。除以0产生，可用于绕过某些数学检查。
* **非规格化数 (Denormalized)**：$E=全0, M \neq 0$。用于填补 0 到最小规格化数之间的空隙，防止下溢（Underflow）突然崩塌。

## 3. 期末必考
* **转换题**：十进制转 IEEE 754 hex。
    * *步骤*：整数转二进制 -> 小数转二进制 -> 规格化移位 -> 计算阶码(+127) -> 拼接。