## 1. 大端 vs 小端
* **定义**：多字节数据在内存中的存放顺序。
    * **小端 (Little Endian)**：低位字节放低地址（反直觉，x86/PC 采用）。记忆口诀：“高高低低”。
    * **大端 (Big Endian)**：高位字节放低地址（符合人类阅读习惯，网络协议/IBM 采用）。
* **DevOps 启示**：网络传输时（TCP/IP）是大端序。如果你在 x86 (小端) 机器上直接发送结构体，必须调用 `htons` / `htonl` 进行转换，否则数据解析会出错。

## 2. 边界对齐
* **原理**：为了提高内存读写效率（减少访存周期），变量地址通常要求是其长度的倍数。
* **空间换时间**：
    * *结构体填充 (Padding)*：编译器会在成员之间插入无用的字节来满足对齐要求。
    * *案例*：`struct { int i; char c; int j; }` 占用 12 字节；而重排为 `struct { int i; int j; char c; }` 可能只占用 9 字节（实际上通常补齐到 12，但成员间空隙减少）。
* **内核开发**：在设计网络协议头或内核结构体时，必须手动管理对齐（`__attribute__((packed))`），否则跨平台会崩。

## 3. 关联链接
* [[网络协议分析]]：Wireshark 解析数据包时，必须知道数据的端序。