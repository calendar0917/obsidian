---
title: "御林-DevOps入门小结"
subtitle: "御林-DevOps入门小结"
summary: "将入门题的知识点整合到一起，方便查询"
description: "将入门题的知识点整合到一起，方便查询"
image: "https://raw.githubusercontent.com/calendar0917/images/master/20251021193711745.png"
date: 2025-10-21
lastmod: 2025-10-25
draft: false
toc:
 enable: true
hiddenFromHomePage: false
weight: false
categories: ["CTF"]
tags: ["CTF"]
---

## Linux 入门

[御林招新题：DevOps-Linux入门](https://calendar0917.github.io/posts/御林-linux入门/)

### 一、环境搭建
完成centos7版本Linux系统的服务器与云服务器部署，通过终端工具远程连接操作。

### 二、命令基础
1. 口令修改：`passwd`命令修改用户密码。
2. 基础命令：`ls`（查看目录）、`mkdir`（创建目录）、`cd`（切换目录）。

> `cd -`：切换到上次所在目录

1. 帮助查询：`man 命令名`获取命令详细帮助，如`man ls`。

### 三、文件与目录操作
1. 定位切换：`pwd`显示当前目录，`cd`切换目录。
2. 查看操作：`ls`搭配`-l`（详细属性）、`-lh`（人性化大小）、`-t`（时间排序）、`-a`（隐藏文件）等选项。
3. 目录管理：`mkdir`创建、`rmdir`删除空目录。
4. 文件操作：`touch`创建空文件；`cp`（复制）、`mv`（移动/重命名）、`ln`（硬链接）、`ln -s`（软链接）、`rm`（删除）。
5. 内容查看：`cat`命令查看文件内容（不可查看目录）。

> - Q1: 如何实时查看一个正在增长的日志文件？
>   - `tail -f file`
>
> - Q2: 如果日志文件被logrotate归档（重命名）了，tail -f会怎样？如何保证持续跟踪？
>   - tail -f 会停止输出 (因为它跟踪的是inode)。应该用 tail -F，它会检测文件名变化并重新打开文件。
>
> - `grep`
>   - `-r` 递归查找，`-l` 只列出文件名
>
> - `watch [选项] 命令`
>
>   - `-n 秒数`：指定执行命令的间隔时间（默认 2 秒）。
>
>   - `-d`：高亮显示两次输出之间的差异（方便观察变化部分）。
>
>   - `-t`：不显示顶部的标题栏（包含执行时间、命令等信息）。

### 四、文件和目录权限
1. 权限解读：10位权限字符串，第1位为文件类型，2-4位所有者权限，5-7位所属组权限，8-10位其他用户权限；`r=4`、`w=2`、`x=1`、`-=0`。
2. 权限修改：`chmod [用户][操作][权限] 文件名`，用户含`u/g/o/a`，操作含`+/-/=`。

### 五、vi编辑器
1. 基础操作：`vi 文件名`创建文件；`:wq`保存退出，`:q!`强制退出。
2. 光标移动：`k/j/h/l`上下左右，`w/b`单词间移动，`^/$`行首尾，`gg/G`文首尾。
3. 文本编辑：`i/I/a/A/o/O`进入插入模式；`nx`（删n字符）、`ndd`（删n行）删除内容；`r/R`修改内容。
4. 进阶功能：`:set number`显示行号；`:!command`执行系统命令；`:%s/old/new/g`全局替换；`/pattern`查找内容。
5. 复制撤销：`nyy`复制n行、`p`粘贴；`u`撤销、`ctrl+r`重做。

### 六、文件操作进阶
1. 通配符：`ls a*`查找指定目录下以`a`开头的文件。
2. 文件查找：`find 目录 -type f [-name] -printf "%f\n"`查找文件并显示文件名。
3. 内容排序：`sort`（正序）、`sort -r`（逆序）排序文件内容。
4. 部分显示：`head -n 数字`（前n行）、`tail -n 数字`（后n行）。

> - sed 流编辑器 `sed [选项] '编辑命令' 文件`
>   - `sed 's/old/new/g' file`：替换所有行中的 `old` 为 `new`（`s` 是替换操作）
> - `awk '模式 { 动作 }' 文件`
>   - 用于信息统计

### 七、文件权限进阶
1. 链接区别：软链接适用于跨分区/目录快捷方式；硬链接适用于同一分区文件共享，源文件删除仍可用。

> **硬链接**: 共享同一个inode，本质是同一个文件。删除一个不影响另一个，直到inode引用计数为0。不能跨文件系统，不能链接目录(防止创建循环引用，导致遍历混乱)。
>
> **软链接**: 一个独立文件，内容是它所指向文件的路径。类似快捷方式。

1. 权限恢复：`chmod u=rwx,g=rx,o=rx 目录名`或`chmod 755 目录名`恢复默认权限。

> - `ls -l` 输出格式是？
>   - 第一位是文件类型 d: 目录, -: 文件, l: 链接
>   - 所有者读写执行-组用户读执行-其他用户读执行
> - 如何递归添加权限？
>   - `chmod -R a+r mydir`
> - 什么是 SUID, SGID 和 Sticky Bit (粘滞位)？
>   - SUID：当普通用户执行带有 SUID 权限的可执行文件时，该进程的**有效用户 ID（UID）会临时变为文件所有者的 UID**。
>     - `chmod 4755 test.sh`
>   - SGID：用于文件类似SUID；用于目录则在此目录中创建的新文件，其所属组会自动继承目录的所属组。
>     - `chmod 2775 /opt/project`
>   - StickyBit：只有目录所有者、文件所有者或root才能删除目录中的文件
>     - `chmod 1777 /tmp`
> - 如何查看一个用户的UID, GID 和他属于的所有组？
>   - `id name`
> - 如何把用户 www-data 添加到 docker 组，并且不覆盖他已有的组？
>   - `usermod -aG docker www-data` (-a 代表 append 追加)

## Linux 进阶

[御林招新题：Linux 进阶](https://calendar0917.github.io/posts/御林-linux进阶/)

### 一、系统与进程管理
1. **特殊进程**：PID为1的是`init`进程，是系统首个用户空间进程，作为所有进程的祖先，负责系统初始化、服务启动、运行级别设置及系统关闭收尾工作。
2. **进程查看**：`ps -A -f`查看所有活跃进程，通过PID（进程ID）和PPID（父进程ID）分析父子关系。
3. **端口与进程处理**：用`lsof`或`netstat`（搭配`-t/-u/-l/-p/-n`等选项）查找占用指定端口的进程PID；通过`kill -pid PID`强制终止进程。

> - 一个应用服务器突然响应很慢，你的排查思路是什么？
>   1. top/htop 看CPU/内存占用和Load Avg。
>   2. free -m / vmstat 看内存/Swap。
>   3. iostat -x / iotop 看磁盘I/O。
>   4. ss -tnp / netstat 看网络连接数。
>   5. dmesg -T 看内核/硬件有无报错。
> - 如何查看某个进程打开了哪些文件？
>   - `lsof -p <PID>`。或者进入 `/proc/<PID>/fd/` 目录查看。

### 二、网络与文件系统
1. **文件系统结构**：采用树形结构，`/`为根目录，包含系统核心文件和目录，普通用户多为只读权限；`/home`是普通用户主目录集合，用户拥有完全操作权限。关键子目录功能：
    - `/bin`：存放普通用户和超级用户均可执行的基本命令。
    - `/sbin`：存放仅超级用户可执行的系统管理命令。
    - `/etc`：存储系统各类配置文件。
    - `/dev`：存放硬件设备抽象文件。
    - `/proc`：虚拟文件系统，反映系统运行状态。
    - `/usr`：存放用户安装的应用程序及文件。
    - `/var`：存放日志、邮件等动态变化文件。
    - `/tmp`：存放临时文件，系统重启后清空。
2. **GRUB**：统一引导加载程序，负责系统启动时加载Linux内核并移交控制权，支持多系统启动选择和内核参数临时修改。

> - Nginx 相较 Apache 有什么优势？
>
>   - Nginx：事件驱动 (Event-driven), 异步非阻塞 (Asynchronous)。内存占用少，高并发能力强，非常适合做反向代理和静态文件服务。
>   - Apache：传统进程/线程模型 (prefork/worker)。功能模块丰富 (如 .htaccess)，但在高并发下资源消耗大。
>
> - Nginx 如何实现负载均衡？
>
>   - `upstream backend { server 1.1.1.1; server 1.1.1.2; }`
>
>   - ```
>     server { listen 80;
>     	server_name your-domain.com;
>     	location / { 
>     	proxy_pass http://localhost:3000;
>     	proxy_set_header Host $host; } }
>     ```

### 三、文件内容处理
1. **模式查找**：`grep '^t' /etc/passwd`查找`/etc/passwd`中以`t`开头的文本行。
2. **管道与重定向**：`grep -E [0-9] /etc/passwd | wc -l > hello/digit_count.txt`，统计文件中含数字的行数并将结果重定向到指定文件。

### 四、高级系统管理
1. **systemd服务**：
    - 编写`.sh`脚本实现每分钟向指定日志文件写入当前时间。
    - 配置service文件，通过`systemctl enable`启用开机自启、`systemctl start`启动服务，`systemctl status`查看服务状态。
2. **内核模块**：`lsmod`列出已加载内核模块；`modprobe 模块名`加载模块，`modprobe -r 模块名`卸载模块。如`dummy`虚拟网络设备模块，可用于网络测试、服务绑定隔离等场景。

> - 你修改了一个 `sshd.service` 的 `.service` 配置文件 (e.g. 更改了启动参数)，为什么 `systemctl restart sshd` 后不生效？
>   - 修改 `systemd` 的单元(unit)文件后，必须先执行 `systemctl daemon-reload` 来重载配置，然后再 `restart` 服务。
> - `systemctl reload nginx` 和 `systemctl restart nginx` 有什么区别？
>   - restart: "先停后启"。
>   -  reload: "平滑重载"。不杀死主进程，只让主进程重读配置，并优雅地启动新的worker进程，旧的worker进程服务完当前请求后退出。服务不中断。
>     - 当修改了 nginx 上游配置时(比如 nginx.conf 里 load_module 路径）或 `.service` 文件，必须 restart

### 五、现代文件系统
以Btrfs为例：
1. **创建与挂载**：通过虚拟磁盘模拟分区，用`mkfs.btrfs`格式化，`mount`命令挂载到指定目录，`btrfs subvolume create`创建子卷。
2. **快照与回滚**：`btrfs subvolume snapshot -r`创建只读快照；修改源文件后快照内容保持不变，通过删除源子卷并基于快照重新创建实现回滚。

> - 什么是LVM？它相比传统分区的核心优势是什么？
>   - LVM (Logical Volume Manager) 逻辑卷管理。它在物理磁盘(PV)和文件系统之间加了一个抽象层(VG, LV)。
>   - 核心优势: 弹性伸缩。可以轻松地扩容或缩容文件系统，甚至跨越多块物理磁盘。
> - 描述一下LVM扩容一个已挂载目录 (e.g. /data) 的完整步骤。
>   - 1. (如有新硬盘) pvcreate /dev/sdc。
>     2.   vgextend vg_data /dev/sdc (VG扩容)。
>     3. lvextend -L +100G /dev/vg_data/lv_data (LV扩容)。
>     4. resize2fs /dev/vg_data/lv_data (文件系统扩容, 假设是ext4)。

### 六、系统优化与维护
1. **缓存与日志管理**：`journalctl --since "10 minute ago" | grep -E "error|fail"`查看指定时间内含目标关键字的系统日志；`journalctl --vacuum-time=7d`清除超过7天的系统日志。
2. **内核参数调整**：
    - `sysctl net.core.somaxconn net.ipv4.tcp_max_syn_backlog`查看TCP最大连接数限制参数。
    - `sysctl -w net.core.somaxconn=50000`临时修改参数值，`sysctl -a`验证生效。
    - 影响：提升高并发Web服务器的连接处理能力，但会增加内存消耗，资源不足时可能导致系统不稳定。

> - 内核模块内核模块通常放在哪个目录下？
>   -  `/lib/modules/$(uname -r)/`

### 七、软件包与服务管理

1. 安装命令的区别
   - `dnf install <软件名>`：从系统已配置的 **软件仓库（repo）** 中下载并安装软件包。
   - `dnf localinstall <本地包文件.rpm>`：安装本地已下载的 `.rpm` 包文件
   - 无网络时自己配置镜像源：配置 `/etc/yum.repos.d/local.repo` 

### Linux 防火墙

待补充

## 服务器与 PC 硬件知识

#### PC 硬件基础

- 装机大致流程
  1. CPU装主板 -> 涂硅脂 -> 装散热。
  2.  内存条插主板。
  3.  M.2 SSD 装主板。
  4.  主板装进机箱 (固定IO挡板)。
  5.  装电源，并连接主板供电、CPU供电。
  6.  (如有) 装显卡，连接显卡供电。
  7. 连接机箱跳线 (开机、重启、指示灯)。
  8. 理线，盖侧板。

#### 服务器硬件

- RAID 5:
  -  至少3块盘，N-1容量，条带化+分布式奇偶校验。
  - 优点：读性能好，空间利用率高。
  - 缺点：写性能一般（有校验开销），一块盘坏后重建时性能差且风险高。
- RAID 10: 
  - (RAID 1+0)，至少4块盘。先做RAID 1镜像，再做RAID 0条带。
  - 优点：读写性能都很好，冗余性高（每组镜像坏一块盘仍可工作）。
  - 缺点：空间利用率低 (50%)。
- 服务器的 ECC 内存条：
  - 能检测并纠正单位比特的内存错误。服务器追求高稳定性，内存错误可能导致数据损坏或系统崩溃，所以必须用ECC。
  - 会有一定性能开销（读写校验位），但完全值得
- 热插拔(Hot-Swap)
  - 在服务器不关机的情况下，可以安全地移除或插入硬件。最常见的是热插拔硬盘和电源。
  - 物理接口(SAS/SATA)支持
  - 操作系统和RAID卡支持，允许在运行时"摘除"和"加入"设备 (e.g. echo 1 > /sys/block/sda/device/delete)。

## shell 基础

[御林招新题：shell 入门](https://calendar0917.github.io/posts/御林-shell入门/)

### 一、重定向与管道

1. 三大标准流概念
   - 标准输入（stdin）：默认从键盘获取输入。
   - 标准输出（stdout）：默认输出到终端，展示程序正常结果。
   - 标准错误（stderr）：默认输出到终端，展示程序错误信息。
2. 输出重定向
   - `>`：覆盖式重定向标准输出到文件，文件不存在则创建。
   - `>>`：追加式重定向标准输出到文件。
   - `2>`：覆盖式重定向标准错误到文件。
   - `2>>`：追加式重定向标准错误到文件。
3. **管道操作**：`|` 将前一个命令的标准输出作为后一个命令的输入，如 `ls | grep 'txt'` 筛选出含 “txt” 的文件名。

### 二、变量与引号

1. 变量操作
   - 定义：`变量名=值`（等号两侧无空格）。
   - 引用：`$变量名` 或 `${变量名}`。
   - 取消定义：`unset 变量名`。
2. 引号区别
   - 单引号 `' '`：完全原样输出内容，不进行变量、命令替换。
   - 双引号 `" "`：支持变量替换和命令替换（配合 `$()` 或反引号）。
   - 反引号 `` ``：执行内部命令并返回输出结果，推荐用 `$()` 替代以支持嵌套。

### 三、参数与条件判断

1. 命令行参数

   - `$1`~`$n`：对应第 1 到第 n 个命令行参数。
   - `$#`：参数总个数；`$0`：脚本文件名。
   - `$*`：将所有参数视为单个字符串；`$@`：将每个参数视为独立字符串。

2. 条件判断

   - 基础语法：

   ```sh
   if [条件1]; then
       # 条件1为真时执行的命令
   elif [条件2]; then
       # 条件2为真时执行的命令
   else
       # 所有条件都为假时执行的命令
   fi
   ```

   `test` 命令和 `[]`（方括号）在 Shell 中用于进行条件测试，可以对文件、字符串、数字等进行比较。`[]` 是 `test` 命令的另一种写法，使用起来更简洁。

   - 文件：`-e`（存在）、`-f`（普通文件）、`-d`（目录）等。
   - 字符串：`=`（相等）、`!=`（不等）、`-z`（空字符串）等。
   - 数字：`-eq`（相等）、`-gt`（大于）、`-lt`（小于）等。

### 四、循环

1. for 循环
   - 遍历元素：`for 变量 in 元素1 元素2...; do 命令; done`。
   - 范围遍历：`for 变量 in {起始值..结束值}; do 命令; done`。
2. **while 循环**：`while 条件; do 命令; done`，条件为真时重复执行循环体。

### 关键注意点

- 参数判断需用双引号包裹变量，避免空格等特殊字符问题。
- 遍历目录文件需用 `"$1"/*` 表示目录下所有内容。
- `echo -n` 可取消默认换行，按需手动添加换行保证格式整洁。

> - `.bashrc` 和 `.bash_profile` 的差别？
>
>   - `.bash_profile`: 只在 "Login Shell" (登录Shell，如SSH登入) 时加载一次。 
>   - `.bashrc`: 在 "Interactive Non-Login Shell" (交互式非登录Shell，如打开新终端窗口) 时加载。
>
> - `alias` 是什么？
>
>   - 简化命令的配置，写入用户 `.bashrc` 等配置文件
>
>   - 如果加在了 `.bashrc`，在系统SSH登入时只加载 `.bash_profile`，`.bash_profile` 需要 `source ~/.bashrc`。
>
>   - ```sh
>     if [ -f ~/.bashrc ]; then
>         . ~/.bashrc
>     fi
>     ```
>
> - 脚本开头 `set -e` / `set - u`
>
>   - `set -e: "Exit on Error"`。脚本中任何命令返回非0退出码（即出错）时，立即退出。
>   -  `set -u: "Unbound Variable"`。试图使用未定义的变量时，视为错误并退出。
>
> - screen 和 `tmux` 的作用？
>
>   - 会话保持：SSH断开连接后，服务器上的任务（如编译、跑脚本）不会中断。
>
>   - 多路复用：在一个终端窗口中创建多个"窗口"和"窗格"，方便同时操作。
>
>   - | 操作         | `screen` 命令 / 快捷键         | `tmux` 命令 / 快捷键              |
>     | ------------ | ------------------------------ | --------------------------------- |
>     | 新建会话     | `screen` 或 `screen -S 会话名` | `tmux` 或 `tmux new -s 会话名`    |
>     | 列出所有会话 | `screen -ls`                   | `tmux ls` 或 `tmux list-sessions` |
>     | 断开当前会话 | `Ctrl + a + d`                 | `Ctrl + b + d`                    |
>     | 重新连接会话 | `screen -r 会话名/ID`          | `tmux attach -t 会话名/ID`        |
>     | 新建窗口     | `Ctrl + a + c`                 | `Ctrl + b + c`                    |
>     | 垂直拆分面板 | 需额外配置                     | `Ctrl + b + %`                    |
>     | 横向拆分面板 | 需额外配置                     | `Ctrl + b + "`                    |

## Git版本管理

[御林招新题：Git 版本管理](https://calendar0917.github.io/posts/御林-git版本管理/)

### 一、安装与配置
1. **安装验证**：在Linux系统安装Git后，通过`git --version`命令确认安装成功。
2. **全局配置**：配置提交者信息，命令如下：
    - `git config --global user.name "用户名"`
    - `git config --global user.email "邮箱地址"`

### 二、仓库创建与克隆
1. **本地仓库**：在目标文件夹中初始化Git仓库（具体命令未明确给出，常规为`git init`）。
2. **远程克隆**：使用`git clone 远程仓库地址`克隆公开仓库到本地，例如`git clone https://github.com/calendar0917/learning_log.git`。
3. **代理配置**：可通过`clashctl on`开启代理、`clashctl off`关闭代理等命令配置网络代理以解决克隆问题。

### 三、文件提交与同步

1. **暂存与提交**
    - `git add 文件名`：将修改文件添加到暂存区。
    - `git commit -m "提交信息"`：提交暂存区文件并添加说明。
2. **凭据缓存**：配置Git凭据缓存避免重复登录，命令如下：
    - `git config --global credential.helper cache`（默认缓存15分钟）
    - `git config --global credential.helper 'cache --timeout=2592000'`（自定义缓存时间，如30天）
3. **远程同步**
    - `git pull`：从远程仓库拉取最新变更。
    - `git push`：将本地提交推送到远程仓库，需输入用户名及Personal Access Token验证。

### 四、分支管理
1. **分支操作**
    - 创建分支：`git branch 分支名`（如`git branch feature-a`）。
    - 切换分支：`git checkout 分支名`。
    - 创建并切换分支：`git checkout -b 分支名`。
2. **修改与合并**
    - 在分支上修改文件后，执行`git add`和`git commit`提交变更。
    - 切换回主分支（`main`/`master`），通过`git merge 分支名`合并分支修改。
3. **分支删除**：合并完成后，用`git branch -d 分支名`删除分支。

### 五、历史记录与回溯
1. **查看历史**：`git log`命令查看提交历史，包含提交ID、作者、时间及提交信息。
2. **核心概念**
    - 工作区：实际存放项目文件的可见目录。
    - 暂存区：临时保存文件修改的区域，通过`git add`添加文件至此。
3. **版本回溯**
    - `git revert 提交ID`：创建新提交抵消目标提交的修改，不改变历史记录。
    - `git reset`：重置HEAD指针到指定版本，不同模式效果不同：
        - `--hard`：重置HEAD指针、暂存区和工作区。
        - `--soft`：仅重置HEAD指针，保留暂存区和工作区内容。
        - `--mixed`：重置HEAD指针和暂存区，保留工作区内容。

### 六、远程仓库进阶
1. **添加远程仓库**：`git remote add 仓库别名 仓库地址`，例如`git remote add gitee https://gitee.com/calendar917/learning_log.git`。
2. **查看远程仓库**：`git remote -v`查看已配置的远程仓库信息。
3. **多仓库同步**：`git push 仓库别名 分支名`将本地分支推送到指定远程仓库，如`git push gitee main`。

## Docker入门

[御林招新题：docker 入门](https://calendar0917.github.io/posts/御林-docker入门/)

### 一、安装与配置
1. **安装验证**：在Linux系统安装Docker Engine后，通过`docker version`和`docker info`命令确认安装与配置正常。
2. **镜像源配置**：配置国内镜像源以提升镜像下载速度。

### 二、运行容器
1. **基础容器操作**
    - 拉取镜像：`docker pull 镜像名`，例如`docker pull hello-world`。
    - 运行容器：`docker run 镜像名`，如`docker run hello-world`可观察容器输出。
2. **进阶容器运行**
    - 拉取并运行`searxng`容器：`docker pull searxng/searxng`，`docker run -d -p 8080:8080 searxng/searxng`。
    - 关键参数：`-d`（后台运行）、`-p 主机端口:容器端口`（端口映射）、`-v 主机目录:容器目录`（数据卷挂载）、`--name`（指定容器名）、`-it`（交互式运行）。
3. **验证**：浏览器访问`http://localhost:8080`确认`searxng`服务正常。

### 三、核心概念
1. **镜像（Image）**：类似不可修改的安装包，整合了应用所需的运行环境。
2. **容器（Container）**：基于镜像创建的可操作实例，是独立隔离的沙箱环境，支持启动、删除等操作。
3. **Dockerfile**：自动化构建镜像的配置文件，可编写镜像所需环境，替代手动安装操作。

### 四、Docker Compose
1. **工具作用**：Docker官方工具，用于定义和运行多容器应用，可统一管理多个容器的启停、网络配置及数据卷挂载，解决多容器协同操作的繁琐问题。
2. **配置文件**：`docker-compose.yml`是核心配置文件，可定义服务（指定镜像、端口映射等）、网络（实现容器间通信）、数据卷（实现数据共享）。

### 五、编写Dockerfile
#### 功能需求

基于最新`ubuntu`镜像，安装`nginx`并设置其在容器启动时自动运行。
#### 实现代码
```dockerfile
FROM ubuntu:latest
RUN apt-get update && \
    apt-get install -y nginx && \
    rm -rf /var/lib/apt/lists/*
CMD ["nginx", "-g", "daemon off;"]
```
#### 操作与验证
- 构建镜像：`docker build -t my-ubuntu-nginx .`。
- 运行容器：`docker run -d -p 80:80 my-ubuntu-nginx`。
- 说明：Ubuntu镜像为精简根文件系统，共享宿主机Linux内核，体积小无需完整下载。

### 六、Docker Compose部署多服务
#### 功能需求
部署`nginx`服务（端口映射8081:80）和`mysql`服务（设置root密码）。
#### 配置文件（docker-compose.yml）
```yaml
version: '3'
services:
  nginx-service:
    image: nginx:latest
    ports:
      - "8081:80"
  mysql-service:
    image: mysql:latest
    environment:
      MYSQL_ROOT_PASSWORD: 1234
    ports:
      - "3306:3306"
```
#### 操作与验证
- 启动服务：`docker compose up -d`。
- 确认运行：`docker ps`查看两个容器的运行状态。

## Docker进阶

[御林招新题：docker 进阶](https://calendar0917.github.io/posts/御林-docker进阶/)

### 一、多阶段构建

1. **概念与优势**：在单个Dockerfile中定义多个构建阶段，构建阶段使用含编译、打包工具的完整镜像完成构建操作，运行阶段使用轻量级镜像仅复制构建产物，可剔除冗余内容，大幅精简镜像体积。
2. **实战案例（打包Python Flask应用）**
    - 构建阶段：基于`python:3.9`镜像，设置工作目录，复制并安装依赖，复制应用代码。
    - 运行阶段：基于`python:3.9-slim`轻量镜像，从构建阶段复制依赖文件、应用代码及安装好的依赖包，暴露端口并启动应用。
3. **关键说明**：直接使用轻量镜像单阶段构建可能因缺少编译工具导致依赖安装失败；可通过临时容器或单阶段容器输出依赖路径，确定需复制的文件路径。
4. **效果验证**：多阶段镜像（148MB）远小于单阶段镜像（1.1GB），差异源于基础镜像精简及冗余内容剔除。

### 二、镜像版本管理与标签

1. **标签操作**：使用`docker tag <镜像ID> 镜像名:<标签>`为镜像打标签，例如为多阶段镜像添加`1.0.0`和`latest`标签。
2. **验证方式**：通过`docker images`命令查看镜像标签是否正确应用，同一镜像可对应多个标签。

### 三、镜像的打包与加载
1. **打包镜像**：`docker save -o 文件名.tar 镜像名:标签`，将指定镜像打包为tar文件，用于无Docker Registry环境下的镜像迁移。
2. **加载镜像**：先通过`docker rmi 镜像名:标签`删除本地原有镜像，再用`docker load -i 打包文件.tar`加载镜像。
3. **验证步骤**：执行`docker images`确认镜像加载成功，运行镜像验证其可用性。

### 四、推送到私有仓库
1. **操作流程**
    - 启动本地临时Docker Registry容器。
    - 用`docker tag`命令为镜像添加指向私有仓库的标签（如`localhost:5000/your-app:1.0.0`）。
    - 执行`docker push`将镜像推送到私有仓库。
    - 用`docker pull`从私有仓库拉取镜像，验证推送与拉取流程。
2. **补充说明**：删除多标签镜像时，仅删除指定标签，直至最后一个标签删除才会彻底删除镜像；多容器应用（基于Docker Compose）可在配置文件目录下用`docker compose stop`统一停止。

## 内网穿透与流量转发

[御林招新题：内网穿透与流量转发专题](https://calendar0917.github.io/posts/御林-网络转发/)

### 一、Nginx 反向代理
1. **概念**：客户端向反向代理服务器发请求，代理服务器转发至内网实际服务器，再将响应返回客户端，客户端无需知晓内网服务详情，Nginx 可承担该角色。
2. **实操步骤**
    - 在公网服务器安装 Nginx。
    - 修改配置文件，添加 `server` 块，通过 `proxy_pass` 指令将请求转发到内网服务的 IP 和端口，同时配置请求头传递参数。
    - 验证：通过公网 IP 访问 Nginx 服务器，确认能显示内网服务页面。

### 二、Autossh 端口转发
1. **核心作用**：封装 SSH 工具，自动监控并重建断开的 SSH 反向隧道，保证连接持久性，实现内网端口暴露到公网。
2. **实操步骤**
    - 内网机器安装 Autossh，生成 SSH 公钥并上传至公网服务器。
    - 执行命令建立反向隧道：`autossh -M 20000 -fCNR public_server_ip:8000:localhost:5000 root@public_server_ip`。
    - 关键配置：修改公网服务器 `sshd_config` 中 `GatewayPorts` 为 yes，开放安全组对应端口。
    - 验证：访问公网服务器的指定端口，确认能连接内网服务。

### 三、Tailscale 零配置网络
1. **概念**：搭建零配置虚拟私有网络（VPN），简化配置流程，实现不同网络环境设备的点对点互联。
2. **实操步骤**
    - 在公网服务器和内网机器分别安装 Tailscale，注册并登录账户加入网络。
    - 查看设备的 Tailscale IP，通过该 IP 直接访问内网服务。
    - 验证：在公网服务器上通过内网机器的 Tailscale IP 访问其服务，无需端口转发。

### 四、Frp (Fast Reverse Proxy)
1. **概念**：高性能内网穿透反向代理应用，采用客户端-服务端模式暴露内网服务。
2. **实操步骤**
    - 下载 Frp 安装包，在公网服务器部署服务端（frps），内网机器部署客户端（frpc）。
    - 配置服务端 `frps.ini` 的通信端口，客户端 `frpc.ini` 的服务端地址、本地服务地址及公网映射端口（建议用 TCP 类型避免域名依赖）。
    - 分别启动服务端和客户端程序。
    - 验证：通过公网服务器的 IP 和配置的映射端口，访问内网服务。

## 文件服务器

[御林招新题：文件服务器](https://calendar0917.github.io/posts/御林-文件服务器/)

### 一、文件共享协议理解
1. **SMB/CIFS**
    - 作用：局域网内实现文件、打印机等资源共享，Windows 网络原生支持，访问方式接近本地文件。
    - 典型场景：企业 Windows 办公网络共享文档、学校计算机教室共享教学资料。
    - 特点：局域网传输高效、使用便捷，但安全性不足。
2. **SFTP**
    - 作用：基于 SSH 协议的安全文件传输协议，传输过程加密，保障数据安全。
    - 典型场景：Linux 服务器间文件备份同步、开发者向远程 Linux 服务器上传代码/下载日志。
    - 特点：跨平台兼容性好、传输稳定可靠，但加密会消耗性能，功能专注于文件传输。

### 二、Samba 服务配置（SMB/CIFS）
1. **实操步骤**
    - 安装：`sudo yum install samba samba-client samba-common`。
    - 创建用户：`sudo useradd sambauser`，`sudo smbpasswd -a sambauser` 设置 Samba 密码。
    - 配置共享：创建共享目录并设置权限，修改 `/etc/samba/smb.conf`，添加共享配置（指定路径、授权用户等），重启服务 `sudo systemctl restart smb nmb`。
    - 验证：局域网内 Windows/macOS 设备通过 `\\服务器IP` 访问共享目录，测试文件上传。

### 三、SFTP 服务配置
1. **实操步骤**
    - 准备：安装 SSH 服务 `sudo yum install openssh-server`，启动服务 `sudo systemctl start sshd`。
    - 创建用户：`sudo useradd sftpuser`，`sudo usermod -s /sbin/nologin sftpuser` 限制 Shell 登录。
    - 配置服务：备份并修改 `/etc/ssh/sshd_config`，注释原有 SFTP 配置，启用 `internal-sftp`，匹配用户并限制访问目录，重启 SSH 服务。
    - 验证：使用 FileZilla 等客户端连接，测试文件上传，确认无法执行 Shell 命令。
    - 注意：需将用户主目录权限设为 755 且归属 root，检查配置文件语法避免报错。

### 四、权限精细化管理
1. **实操步骤**
    - 创建组：`sudo groupadd sambagrp`（系统组）、`sudo smbgroupadd sambagrp`（Samba 组）。
    - 配置共享目录：创建目录并设置组归属及权限，修改 `smb.conf` 添加组共享配置，限制仅组内用户读写。
    - 添加用户：创建新用户并加入组，设置 Samba 密码，重启服务。
    - 验证：组内用户可正常读写，非组用户被拒绝访问。

### 五、WebDAV 配置
1. **实操步骤**
    - 安装配置：基于 Nginx 部署，下载并编译安装 Nginx 及 `nginx-dav-ext-module` 插件，配置系统服务。
    - 基础配置：修改 Nginx 配置文件，设置监听端口、认证文件、共享目录及 WebDAV 相关指令，创建认证用户和共享目录。
    - 验证：Windows 设备修改注册表并重启 WebClient 服务后，通过网络位置访问，输入凭据管理文件。

### 六、性能与安全性
1. **性能测试**：使用工具测试大文件传输速度，Samba 传输效率通常高于 SFTP（因 SFTP 加密消耗性能）。
2. **安全加固**
    - 配置 SFTP 密钥认证：生成密钥对，将公钥放入服务器用户的 `authorized_keys` 文件，禁用密码登录（`PasswordAuthentication no`）。
    - 安全优势：密钥认证采用非对称加密，私钥仅存于客户端，可防范密码暴力破解、泄露等风险，安全性远超密码认证。

## Homepage

[御林招新题：Homepage](https://calendar0917.github.io/posts/御林-homepage/)

### 一、安装与基础配置
1. **安装方式**：推荐使用Docker Compose安装，编写`docker-compose.yml`文件，指定Homepage镜像、容器名称、环境变量、端口映射及配置文件挂载目录，执行`docker-compose up -d`启动服务。安装过程中需解决依赖问题（如加装pip3、rust环境等）。
2. **配置调整**：创建本地配置目录并挂载，通过修改环境变量`HOMEPAGE_ALLOWED_HOSTS`解决主机验证问题（可临时设为“*”禁用验证）；修改配置文件设置主页标题（如“我的DevOps控制台”），支持热加载生效。

### 二、服务添加与验证
1. **基础服务配置**：编辑`service.yaml`文件，按分组添加服务，配置服务名称、图标、访问链接及描述，支持添加自有服务（如Searxng）或常用网站（如GitHub、个人博客）。
2. **验证步骤**：重启Homepage服务，通过浏览器访问确认标题修改成功，服务图标可正常点击并跳转至目标页面。

### 三、进阶服务与集成
1. **状态检查服务**：在服务配置中添加`siteMonitor`参数（指定服务访问地址），实现对服务在线状态的自动检查，如配置Searxng服务的状态监控。
2. **Docker集成**：启用Docker socket挂载，安装Portainer可视化工具并配置端口映射，在Homepage中添加Portainer服务，通过配置widget实现容器状态（运行数量、CPU/内存占用等）的展示。

### 四、小部件定制
1. **基础小部件添加**：参考文档配置小部件，例如添加时间小部件，通过设置`text_size`和`format`参数自定义显示样式。
2. **实用小部件集成**：借助Portainer与Homepage的整合能力，实现Docker容器状态的可视化监控，需解决端口映射、认证配置等问题。

### 五、主题与布局自定义
1. **布局调整**：修改`setting.yaml`文件，通过`layout`参数调整服务分组的排列样式（如将单列改为双列）。
2. **主题与样式修改**：更换默认主题，或编辑配置目录下的`custom.css`文件，通过CSS选择器自定义元素样式（如修改服务组名称颜色），可通过浏览器开发者工具定位目标元素类名。

## MySQL专题

[御林招新题：MySQL专题](https://calendar0917.github.io/posts/御林-mysql专题/)

### 一、安装与配置
1. **安装方式**
    - 方法一：通过官方源安装，先下载并安装MySQL 5.7官方源包，再用yum安装服务，最后启动服务并执行安全脚本。
    - 方法二：通过tar包安装，解压包后创建用户组和用户，配置目录权限与`my.cnf`文件，初始化数据库并启动服务，配置系统服务实现管理。
2. **安全配置**：执行`mysql_secure_installation`安全脚本，设置root密码，删除不安全用户和数据库。
3. **验证登录**：配置MySQL命令软链接，使用`mysql -u root -p`命令登录数据库命令行。

### 二、数据库操作与管理
1. **基础操作**
    - 建库建表：`CREATE DATABASE test_db;`创建数据库，`CREATE TABLE students (...)`创建含`id`、`name`、`score`字段的表。
    - 数据插入：`INSERT INTO students (name, score) VALUES (...)`插入数据。
2. **数据导入导出**
    - 导出：`mysqldump -u root -p test_db > test_db_backup.sql`将数据库导出为SQL文件。
    - 导入：先删除数据库并重建，再执行`mysql -u root -p test_db < test_db_backup.sql`恢复数据。

### 三、数据库性能调优
1. **关键参数修改**
    - `innodb_buffer_pool_size`：设置InnoDB缓冲池大小（示例设为2G），用于缓存表数据和索引数据，提高查询性能。
    - `max_connections`：设置最大并发连接数（示例设为500），过小会拒绝连接，过大占用过多系统资源。
2. **配置生效**：修改`/etc/my.cnf`配置文件后重启MySQL服务，通过`SHOW VARIABLES LIKE '参数名'`验证配置。

### 四、应用程序集成与数据处理
1. **Python集成示例**
    - 依赖库：使用`pymysql`库连接数据库，`csv`库处理文件。
    - 核心功能：连接数据库查询`students`表数据，计算学生平均分数，将数据及平均分写入`report.csv`文件。
    - 安全注意：采用参数化查询防止SQL注入，操作完成后关闭游标和连接。
2. **关键操作**：通过游标执行SQL语句，使用`fetchall()`获取数据，借助`csv.writer`写入文件。

### 五、自动化备份与恢复
1. **备份脚本编写**
    - 脚本功能：使用`mysqldump`命令备份指定数据库，为备份文件添加时间戳，检查备份结果并输出日志。
    - 权限设置：执行`chmod +x mysql_backup.sh`为脚本添加执行权限。
2. **定时执行**：通过`crontab -e`添加定时任务，设置脚本每天凌晨1点自动运行。
3. **验证测试**：手动执行脚本，确认备份文件生成；通过`top`或`htop`命令查看系统资源占用情况。

## Python后端

[御林招新题：python 后端](https://calendar0917.github.io/posts/御林-python后端/)

### 一、Flask框架
#### （一）基础应用开发
1. **简单应用创建**：定义首页路由`/`和带参数路由`/hello/<name>`，实现个性化问候功能。
2. **服务器端模板注入（SSTI）漏洞**
    - 漏洞成因：将用户输入直接拼接进模板，通过`render_template_string`渲染执行恶意代码。
    - 漏洞防护：设置黑名单过滤危险字符，或采用安全写法将参数传入模板而非拼接。
    - 漏洞利用：通过构造特定代码（如利用类继承关系调用系统函数）执行恶意操作。

#### （二）核心功能用法
1. **请求与响应**：通过`request`模块获取表单、查询字符串、路径等参数；使用`make_response`自定义响应内容、状态码和响应头；通过`render_template`渲染模板并返回。
2. **会话管理**：设置`app.secret_key`密钥，利用`session`对象存储会话数据，实现用户登录状态保持与页面跳转。
3. **模板语法**：支持变量替换、条件判断、循环遍历等功能，可动态渲染页面内容。

### 二、FastAPI与Sanic框架基础
#### （一）应用创建与路由
1. **FastAPI**
    - 基础路由：定义`/`路由处理GET请求，`/items/{item_id}`路由处理POST请求。
    - 数据校验：借助Pydantic模型定义数据结构，自动完成POST请求数据的校验。
2. **Sanic**
    - 基础路由：创建`/`路由（GET请求）和`/items/{item_id}`路由（POST请求）。
    - 数据处理：手动获取请求体数据并处理，需自行实现数据校验逻辑。
3. **框架区别**：FastAPI支持自动数据校验，开发效率高；Sanic基于异步非阻塞架构，性能更优。

### 三、异步编程实践
（一）异步路由

在FastAPI中创建异步路由`/async-task`，使用`asyncio.sleep`模拟耗时操作，验证其非阻塞特性，对比同步路由可知异步操作不会阻塞其他请求。

（二）异步依赖注入

1. **依赖函数创建**：编写异步依赖函数（如模拟数据库连接），通过`yield`管理资源生命周期（创建→使用→清理）。
2. **核心概念**
    - `await`：仅在异步函数中使用，暂停当前协程等待异步操作完成，不阻塞事件循环。
    - `yield`：创建生成器，中断函数并返回中间结果，后续可从断点继续执行，用于资源管理。
3. **应用场景**：匹配异步编程模型，避免数据库等IO操作阻塞应用，提升并发处理能力。

### 四、项目结构与APIRouter
#### （一）路由模块化
1. **模块拆分**：将API按功能拆分为`users`和`items`等模块，分别在不同文件中定义路由。
2. **APIRouter使用**：每个模块创建`APIRouter`实例，定义该模块的路由与业务逻辑，在主应用中通过`include_router`注册路由并添加前缀。

#### （二）项目结构示例
```
project/
├── main.py          # 主应用入口，注册路由
├── routers/         # 路由模块文件夹
│   ├── users.py     # 用户相关路由
│   └── items.py     # 商品相关路由
```

### 五、中间件与生命周期管理
#### （一）自定义中间件
为FastAPI应用添加HTTP中间件，记录每个请求的处理耗时并打印到控制台，中间件在请求到达路由前和响应返回客户端前执行。

#### （二）应用生命周期管理
1. **替代`on_event`钩子**：使用`lifespan`上下文管理器，更优雅地处理应用启动和关闭逻辑，支持异常捕获与资源清理。
2. **资源初始化与销毁**：在启动阶段创建数据库连接池并存储在`app.state`中，应用关闭时安全关闭连接池，确保资源合理释放。

## LLM专题

[御林招新题：LLM 专题](https://calendar0917.github.io/posts/御林-llm专题/)

### 一、准备工作
1. **账号与API Key获取**：注册LLM服务提供商账号（如硅基流动、阿里云百炼），申请并获取对应API Key，注意不同地域的API Key可能存在差异。

### 二、编程调用API
1. **环境准备**：选用Python语言，安装`openai`库。
2. **脚本编写**：配置客户端（指定API Key和`base_url`），构造请求参数（选择模型、设置对话消息），发送请求并解析返回结果，打印模型回复。
3. **示例模型**：选用`qwen-plus`等模型，可通过官方文档查询支持的模型列表。

### 三、模型能力探索
1. **多模型对比**：调用至少三种不同模型（如`qwen-plus`、`qwen-max`、`deepseek-v3.2-exp`），针对同一问题提问。
2. **差异分析**：从回答风格（结构化程度、语言简洁度）、准确性（内容完整性、专业性）、响应速度及内容深度等维度对比模型表现。

### 四、构建命令行聊天机器人
1. **核心功能**
    - 交互循环：通过无限循环持续接收用户输入，并发送给LLM。
    - 流式输出：配置`stream=True`实现模型回复的实时流式打印。
    - 退出机制：用户输入`quit`或`exit`时，程序优雅退出。
2. **关键实现**：处理流式响应的分块内容，过滤空片段，确保输出格式整洁。

### 五、提示词工程（Prompt Engineering）
1. **角色扮演**：修改系统提示词，让模型扮演特定角色（如Linux导师、幽默段子手），引导模型输出符合角色设定的内容。
2. **指令遵循**：下达复杂指令，要求模型按指定格式（如Markdown）输出内容（如整理Linux命令及示例）。
3. **输出限制**：在提示词中明确约束回答的长度（如100字以内）或格式，规范模型输出结果。

## Agent专题

### 一、工具调用实现
#### （一）工具设计与开发
1. **天气查询工具**
    - 功能：接收城市名参数，调用第三方天气API（如聚合数据API），返回指定城市的实时天气（温度、天气状况、湿度）。
    - 实现：通过`requests`库发送HTTP请求，解析返回的JSON数据，格式化输出结果，包含异常处理机制。
2. **网络搜索工具**
    - 功能：接收关键词参数，调用DuckDuckGo免费搜索API，返回搜索结果摘要（优先提取摘要信息，补充相关主题内容）。
    - 实现：配置API请求参数，处理网络异常和JSON解析异常，过滤无效结果并整理输出。

#### （二）工具调用流程
1. 配置LLM客户端（基于`openai`库，对接阿里云百炼等服务），在请求中声明工具列表及参数规范。
2. LLM自动识别用户需求，生成工具调用指令，包含工具名称和参数。
3. 解析工具调用指令，执行对应工具函数，将结果回传给LLM，由LLM整理为自然语言回答。

### 二、记忆功能实现
1. **核心原理**：通过`messages`列表存储历史对话内容，包括用户输入、LLM响应（含工具调用记录）和工具执行结果。
2. **交互应用**：后续对话中，LLM可从历史记录中提取上下文信息（如用户之前询问的城市），实现追问响应（如用户问“那明天呢？”可关联之前的天气查询需求）。

### 三、多Agent协同工作
#### （一）角色设计
1. **Agent A（规划者）**：负责任务拆解、工具分配和结果整合，接收用户请求后分解为子任务，指定对应工具及参数，等待执行结果并生成最终回答。
2. **Agent B（执行者）**：专注于工具调用执行，接收Agent A的指令，严格调用指定工具，返回原始执行结果，不添加额外处理。

#### （二）协同流程

1. 用户提交复合任务（如“查北京明天天气及著名IT公司”）。
2. Agent A拆解为两个子任务，分别分配给Agent B执行。
3. Agent B调用对应工具（天气查询、网络搜索）并返回结果。
4. Agent A整合子任务结果，以流畅语言回复用户。
5. 关键保障：设计统一的消息传递机制，明确角色分工的提示词，确保指令传递和结果反馈准确。

### 四、知识库集成
#### （一）知识库构建
1. 存储形式：以Markdown文件为载体，按标题分割知识条目，包含标题和正文内容。
2. 语义处理：使用`paraphrase-multilingual-MiniLM-L12-v2`预训练模型，将知识条目转化为向量嵌入，便于语义检索。

#### （二）检索与集成
1. 检索逻辑：接收用户查询关键词，生成查询向量，通过余弦相似度计算匹配最相关的知识条目（设置相似度阈值过滤无效结果）。
2. 系统集成：将知识库查询作为工具加入工具列表，Agent A优先调用该工具回答特定领域问题（如技术概念），提升回答的精准性和定制化程度。