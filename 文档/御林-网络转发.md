---
title: "御林招新题：内网穿透与流量转发专题"
subtitle: "御林招新题：内网穿透与流量转发专题"
summary: "学习内网穿透与流量转发相关知识"
description: "学习内网穿透与流量转发相关知识"
image: ""
date: 2025-10-19
lastmod: 2025-10-19
draft: false
toc:
 enable: true
hiddenFromHomePage: True
weight: false
categories: ["CTF"]
tags: ["CTF"]
---

## **Nginx 反向代理**

> - 什么是反向代理？
>   - 反向代理是一种服务器架构模式，客户端**向反向代理服务器发起请求**，反向代理服务器再将请求**转发到内部网络中的实际服务器**（内网服务），并将实际服务器的响应返回给客户端。从客户端角度看，**仿佛是直接和反向代理服务器交互**，无需知晓背后内网服务的存在。Nginx 作为高性能的 Web 服务器和反向代理服务器，很适合承担这个角色。

- **任务**：在一台可以从公网访问的服务器（或本地虚拟机）上安装 Nginx，并将其配置为反向代理，以转发流量到你的内网服务（例如，在另一台机器上运行的 Web 服务器）。

- **具体操作**：

  - 在公网服务器上安装 Nginx。
  - 修改 Nginx 配置文件，添加一个 `server` 块，并使用 `proxy_pass` 指令将请求转发到你的内网 IP 地址和端口。

  ```conf
  # /etc/nginx/conf.d/reverse-proxy.conf
  # 需要先把 /etc/nginx/nginx.conf 里监听 80 端口的 server 注释掉
  server {
      listen 80;  # 监听80端口（HTTP默认端口）
      server_name 8.137.38.223;  # 公网服务器的IP地址
  
      location / {
          proxy_pass http://127.0.0.1:8001;  # 转发到内网Web服务器的IP和端口
          proxy_set_header Host $host;  # 传递请求头中的Host信息，确保内网服务器能正确识别
          proxy_set_header X-Real-IP $remote_addr;  # 传递真实客户端IP
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # 记录代理链的IP
      }
  }
  ```

  - 验证：通过公网 IP 访问 Nginx 服务器，确认能成功显示内网服务的页面。

  ![image-20251019110710322](https://raw.githubusercontent.com/calendar0917/images/master/image-20251019110710322.png)

## **Autossh 端口转发**

- **任务**：使用 `autossh` 建立一个持久的 SSH 反向隧道，将内网服务的端口暴露到公网服务器上。

> - **SSH 反向隧道**：通常情况下，SSH 隧道是从客户端（能访问公网的机器）主动连接到服务端（公网服务器），实现从客户端到服务端的端口转发。而反向隧道则是**让服务端（公网服务器）主动连接到客户端**（内网机器），从而将内网机器的端口暴露到公网服务器上，**使得公网可以访问内网服务**。
> - **Autossh**：是 SSH 的一个封装工具，它能够**自动监控 SSH 连接的状态**，当连接断开时会自动重新建立连接，保证隧道的持久性，避免因为网络波动等原因导致隧道中断后需要手动重新建立。

- **具体操作**：
  - 在内网机器上安装 `autossh`。
  - 执行 `autossh` 命令，将内网服务的端口（例如 8080）反向隧道到公网服务器的一个指定端口（例如 8000）。

> - 配置 ssh 公钥：
>   - 内网：`ssh-keygen`
>   - 上传到服务器：`ssh-copy-id -i /root/key.pub user@8.137.38.223`

> ```bash
> autossh -M 20000 -fCNR public_server_ip:8000:localhost:5000 root@public_server_ip
> ```
>
> - 各参数解释：
>   - `-M 20000`：指定一个监视端口，autossh 通过这个端口来监视 SSH 连接的状态，确保连接的持久性。
>   - `-f`：将 autossh 放入后台运行。
>   - `-C`：启用压缩，减少数据传输的大小，提高传输效率。
>   - `-N`：不执行远程命令，只进行端口转发。
>   - `-R public_server_ip:8000:localhost:8080`：建立反向隧道，将公网服务器的`8000`端口转发到内网机器的`localhost:8080`（即内网服务的端口）。`user`是公网服务器上的用户名。

- 验证：通过访问公网服务器的 `8000` 端口，确认能访问到内网服务。

> `docker ps -a` 看所有容器；`docker rm` 删除
>
> `docker insepct <image>` 看一下端口

- 配了很久，要注意的点：
  1. autossh 指令：`public_server_ip:8000` 这里要写 `0.0.0.0`，不然只能服务器本地访问
  2. 不知道为什么密钥上传了但是没用
  3. 需要将服务器上的 `/etc/ssh/sshd_config` 中 `GatewayPorts` 改为 yes，否则隧道仅允许目标服务器本地访问 8000 端口
  4. `netstat -tuln | grep 8000` 看服务器 ssh 连接状态；
  5. `ps（process status） aux | grep autossh` 看内网的 autossh 命令
  6. 云服务器还要看一下安全组是不是拦截了

![image-20251019123323350](https://raw.githubusercontent.com/calendar0917/images/master/image-20251019123323350.png)



## **Tailscale 零配置网络**

- **任务**：使用 `Tailscale` 建立一个零配置的虚拟私有网络（VPN），实现内网设备的点对点互联。

> 不需要复杂的网络配置（如端口转发、防火墙规则调整等），就能让分布在不同网络环境（如内网、公网）的设备，像在同一个局域网内一样实现点对点的互联互通。Tailscale 用于简化 VPN 搭建流程

- **具体操作**：

  - 在你的公网服务器和内网机器上分别安装 `Tailscale`。

  > ` curl -fsSL https://tailscale.com/install.sh | sh`
  >
  > 注册 https://login.tailscale.com/

  - 使用你的账户登录并加入 `Tailscale` 网络。

  ```shell
  [root@localhost ~]# tailscale ip
  100.124.165.66
  [root@iZ2vc96n4f90pw7f8dfbfsZ ~]# tailscale ip
  100.75.140.47
  
  # 访问 OK
  [root@iZ2vc96n4f90pw7f8dfbfsZ ~]# curl http://100.124.165.66:5000
  Hello from Flask!
  ```

  - 验证：在公网服务器上，通过内网机器的 `Tailscale IP` 或主机名直接访问其内网服务，无需任何端口转发。

## **Frp (Fast Reverse Proxy)**

- **任务**：使用 Frp 客户端-服务端模式，将内网服务暴露到公网。

> Frp（Fast Reverse Proxy）是一款专注于内网穿透的高性能反向代理应用
>
> 下载 `wget https://github.com/fatedier/frp/releases/download/v0.32.1/frp_0.32.1_linux_amd64.tar.gz`
>
> 安装参考：[CentOS 7 部署frp穿透内网_centos frp-CSDN博客](https://blog.csdn.net/qq_39689711/article/details/134392136)
>
> ```shell
> # 关防火墙
> systemctl stop firewalld && systemctl disable firewalld
> # 关 SELinux
> setenforce 0
> # 创建安装路径
> mkdir -p /usr/local/frps
> # 解压备用
> tar zxvf frp_0.32.1_linux_amd64.tar.gz  -C /tmp
> # 复制 frps 和 frps.ini 两个配置文件
> # 注意！！！ 客户端要复制的是 frpc 和 frpc.ini
> cd /tmp/frp_0.32.1_linux_amd64
> cp frps frps.ini /usr/local/frps
> # 配置
> vim /usr/local/frps/frps.ini
> ```
>
> ```text
> # 内网 frpc.ini
> [common]
> server_addr = 8.137.38.223  # 公网服务器 IP
> server_port = 7000          # 服务端 bind_port
> 
> [web_tcp]  # 模块名可自定义
> type = tcp                   # 改为 TCP 类型
> local_ip = 127.0.0.1
> local_port = 5000
> remote_port = 8001           # 公网服务器上用于访问的端口（需和服务端端口不冲突??冲突！）
> 
> # 服务器 frps.ini
> [common]
> bind_port = 7000  # Frp 服务端与客户端通信的端口
> vhost_http_port = 8080  # 若要通过 HTTP 访问内网 Web 服务，设置此端口
> ```
>
> 

- **具体操作**：

  - 在一台公网服务器上运行 `frps`（服务端）。

  - 在内网机器上运行 `frpc`（客户端），并配置其连接到服务端，将内网服务的端口暴露出去。

  > 启动 `./frps -c ./frps.ini`

  - 验证：通过公网服务器的 IP 和 Frp 配置的端口，确认能访问到内网服务。

- 错了几个点：

  1. 运行内网的时候运行成 `frps` 了 ……

  2. 如果配置为 `http` 的话，还需要域名，所以改成了 `tcp`

     ![image-20251019135932508](https://raw.githubusercontent.com/calendar0917/images/master/image-20251019135932508.png)

![image-20251019135627727](https://raw.githubusercontent.com/calendar0917/images/master/image-20251019135627727.png)