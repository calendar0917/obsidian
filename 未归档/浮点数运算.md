## 1. 运算步骤 (The Pipeline)
浮点运算比整数复杂得多，无法在一个周期内完成。通常分为 5 步：

1.  **对阶 (Align Exponents)**：
    * **核心原则**：**小阶看齐大阶**。
    * *操作*：阶码小的数的尾数右移，直到阶码相等。
    * *代价*：精度丢失（小树的低位被移出）。
2.  **尾数加减 (Add/Sub Mantissas)**：
    * 执行定点加减运算。注意隐含的 "1"。
3.  **规格化 (Normalize)**：
    * **左规**：结果太小 (0.001...)，尾数左移，阶码减。
    * **右规**：结果太大 (10.1...)，尾数右移，阶码加。
    * *溢出检查*：阶码上溢 (Overflow) $\to \infty$；阶码下溢 (Underflow) $\to 0$。
4.  **舍入 (Round)**：
    * 因为对阶或右规导致了位数丢失，需要根据 IEEE 754 规则舍入 (就近舍入、朝0舍入等)。
    * *保护机制*：运算过程中会多保留几位 (**保护位 Guard bit**, **舍入位 Round bit**, **粘位 Sticky bit**) 以保证最后舍入的精度。
5.  **符号位处理**。

## 2. 精度与漏洞 (Precision & Bugs)
* **大数吃小数**：由于对阶机制，如果一个巨大的数 (e.g., $10^{20}$) 加一个很小的数 (e.g., $10^{-20}$)，小树的尾数会全部被移出，导致加法无效。
    * *场景*：在循环累加中，必须先加小数，再加大数。
* **非结合律**：浮点数加法不满足结合律 $(A+B)+C \neq A+(B+C)$。这对科学计算和金融计算是灾难。

## 3. MIPS 浮点指令
* MIPS 有独立的浮点寄存器堆 (`$f0` - `$f31`) 和协处理器 (Co-processor 1)。
* 这说明浮点运算和整数运算在硬件上是物理隔离的。

## 4. 期末生存指南 (Exam Survival)
* **计算题流程**：
    1.  转二进制 (注意 IEEE 754 格式)。
    2.  求阶差 $\Delta E$。
    3.  对阶 (移尾数)。
    4.  尾数加减。
    5.  规格化 (重中之重，别忘了调整阶码)。
    6.  判断溢出。