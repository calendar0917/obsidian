## 1. 核心解构 (The Kernel)
ALU (Arithmetic Logic Unit) 是 CPU 的执行单元。它的本质是**组合逻辑电路**（不包含寄存器）。

* **基本单元**：全加器 (Full Adder, FA)。
    * 输入：$A_i, B_i, C_{in}$
    * 输出：$Sum = A_i \oplus B_i \oplus C_{in}$ (异或), $C_{out}$ (进位)
* **核心矛盾**：**延迟 (Delay)**。
    * 加法是每一位的依赖链。第 31 位的进位依赖于第 0 位的计算结果。这种依赖导致了性能瓶颈。

>[!注意] 注意
>加法器不区分数值类型！只区分加减法（通过反相器和sub位）

## 2. 进位技术的演进 (Evolution)
这是硬件工程师为了让 CPU 跑得更快所做的努力：

1.  **行波进位 (Ripple Carry Adder, RCA)**
    * *机制*：像多米诺骨牌。$C_0 \to C_1 \to \dots \to C_n$。
    * *延迟*：$O(n)$。做 64 位加法太慢，无法支撑高频 CPU。
2.  **先行进位 (Carry Lookahead Adder, CLA)**
    * *机制*：**空间换时间**。通过增加大量逻辑门，提前计算出每一位的进位，不再等待前一位。
    * *核心公式*：
        * 生成因子 (Generate)：$G_i = A_i \cdot B_i$ (只要A, B都为1，必产生进位)
        * 传递因子 (Propagate)：$P_i = A_i + B_i$ (只要A, B有一个为1，进位就能传下去)
        * 进位公式：$C_{i+1} = G_i + P_i \cdot C_i$
    * *架构意义*：这是现代 CPU 能达到 GHz 级别的物理基础。

## 3. 逻辑运算与移位 (Logic & Shift)
* **逻辑运算**：按位 (Bitwise) 操作。AND (掩码提取), OR (置位), XOR (求反/比较)。
* **移位运算 (Shift)**：
    * **逻辑移位**：针对**无符号数**。不管左移右移，空位补 0。
    * **算术移位**：针对**带符号数** (补码)。
        * 左移：补 0 。若移出的位不等于新的符号位，则溢出
        * **右移**：**补符号位** (这是关键！负数右移保持为负)。
    * *C语言映射*：`unsigned int` 触发逻辑移位，`int` 触发算术移位。这是 CTF 中常见的整数逻辑漏洞点。
* 溢出：正 + 正 = 负，或者相反

## 4. 关联链接
* [[数字电路]]：全加器的门电路实现。
* [[汇编语言]]：移位指令 `SHL` vs `SAL`, `SHR` vs `SAR` 的区别。