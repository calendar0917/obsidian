## 1. 核心解构
MIPS 是 RISC 的教科书代表。
* **字长**：32位。所有指令都是 32 位长（定长），按字（4字节）对齐。
* **寄存器**：32 个通用寄存器 (`$0` - `$31`)。
    * **`$0` ($zero)**：**恒为 0**。这是硬件层面的 `/dev/null` 或 `const 0`，用于清零或空操作。
    * **`$sp` ($29)**：栈指针 (Stack Pointer)。
    * **`$ra` ($31)**：返回地址 (Return Address)。**栈溢出攻击的首要目标**。

## 2. 指令格式 (The Big Three)
MIPS 只有三种格式，极致简洁：

1.  **R 型 (Register)**：`OP | rs | rt | rd | shamt | funct`
    * 用于寄存器间的运算 (add, sub, or)。
    * *特点*：操作码 `op` 全为 0，靠 `funct` 区分功能。
2.  **I 型 (Immediate)**：`OP | rs | rt | Immediate(16bit)`
    * 用于带立即数的运算、**Load/Store** (`lw`, `sw`)、**条件分支** (`beq`).
    * *陷阱*：立即数只有 16 位！如果需要 32 位常数，必须用 `lui` (Load Upper Immediate) + `ori` 拼接。
3.  **J 型 (Jump)**：`OP | Address(26bit)`
    * 用于 `j` (跳转), `jal` (跳转并链接/函数调用)。
    * *计算*：目标地址 = `(PC+4)[31:28] | (Address << 2)`。只能在 256MB 区域内跳转。

## 3. 期末/实战考点
* **汇编翻译**：
    * `if (i == j) f = g + h; else f = g - h;`
    * 翻译为 MIPS 需要用到 `bne` (不相等则跳转) 来实现 `else` 逻辑。
* **寻址陷阱**：
    * `lw $s1, 8($s2)` 中，`8` 是字节偏移量。如果数组是 `int A[]`，访问 `A[2]` 的偏移量是 $2 \times 4 = 8$。**不要漏乘数据宽度！**

## 4. 关联链接
* [[IoT安全]]：大量路由器（如 Cisco）和摄像头使用 MIPS 架构，逆向固件时必须掌握 MIPS 汇编。