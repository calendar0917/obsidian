## 1. 核心解构：统一加减法
计算机内部**没有减法器**，只有加法器。
* **补码魔法**：$A - B = A + (-B)_{补} = A + (\sim B + 1)$。
* **硬件实现**：通过一个 `Sub` 控制信号，控制多路选择器 (MUX) 对 B 进行取反，并向最低位进位 $C_{in}$ 输入 1。

## 2. 标志位 (Flags) - *逆向工程的灵魂*
ALU 每次运算都会产生状态，存放在 PSW (Program Status Word) 或 EFLAGS 寄存器中。

| 标志位 | 名称 | 物理含义 | 触发条件 | 安全/逆向意义 |
| :--- | :--- | :--- | :--- | :--- |
| **ZF** | Zero Flag | 结果为零 | Result == 0 | `JE`/`JZ` (Jump if Equal)。用于判断密码是否匹配。 |
| **SF** | Sign Flag | 结果为负 | 最高位 (MSB) == 1 | `JS` (Jump if Sign)。判断正负。 |
| **OF** | Overflow Flag | **带符号数**溢出 | $C_n \oplus C_{n-1} = 1$ | `JO`。**有符号数**计算结果超出了范围（如正+正=负）。 |
| **CF** | Carry Flag | **无符号数**溢出 | 最高位进位/借位 | `JC`/`JB` (Jump if Below)。**无符号数**越界。 |

### *深度辨析：OF vs. CF*
这是初学者最容易混淆的点，也是漏洞挖掘的关键：
* **CPU 不知道**你算的是有符号数还是无符号数。它同时计算 OF 和 CF。
* **编译器知道**。
    * 如果你定义 `unsigned int`，编译器生成检查 `CF` 的指令 (`ja`, `jb`)。
    * 如果你定义 `int`，编译器生成检查 `OF` 的指令 (`jg`, `jl`)。
* *漏洞场景*：如果你用有符号整数做长度检查 (Signed Comparison)，攻击者构造一个巨大的负数，可能会绕过检查 (因为负数 < 限制)，但在后续 `memcpy` 中被当做巨大的无符号数 (Length)，导致缓冲区溢出。

## 3. 乘除法硬件逻辑
* **乘法**：
    * **慢速**：移位 + 加法 (Shift and Add)，需要 n 个时钟周期。
    * **快速**：阵列乘法器 (Array Multiplier) 或 流水线乘法器。空间换时间，单周期完成。
* **MIPS 实现**：乘法结果可能是 64 位，MIPS 使用 `Hi` (高32位) 和 `Lo` (低32位) 两个特殊寄存器存储。

## 4. 关联链接
* [[软件安全]]：整数溢出 (Integer Overflow) 漏洞利用。
* [[逆向工程]]：条件跳转指令与标志位的对应关系。